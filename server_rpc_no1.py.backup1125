import pickle
import sys
import re
import os.path
import logging
import datetime
from datetime import datetime
import Pyro4
import os
import json

#
# TCSS 558 - Fall 2014
# Project 3, rcp multi threaded client/server
# File: client_rcp.py
# Authors Wiehan Jiang and Jaylene Sheen
# Date: 11/04/2014
#

class RPC_Server(object):

    def __init__(self, number):
        self.distributed_db_init(number)
        self.pull_mapping_table(number)
        self.self_check(number)

    def self_check(self, number):
        if not os.path.isfile('database_no%s.db'%number):
           print "[WARNING][%s]DB is empty on Server#%s. Will create a default DB for this server." %((str(datetime.now())), number)
           logging.info("[WARNING][%s]DB is empty on Server#%s. Default DB has been created on this DB." %((str(datetime.now())), number))
           self.db = {'Jaylene%s'%number: '2533550659', 'Weihan%s'%number: '2065197252'}           
           pickle.dump(self.db, open('database_no%s.db'%number, 'wb'))
        if (os.path.isfile('database_no%s.db'%number)):
           self.db = pickle.load(open('database_no%s.db'%number, 'rb'))

        self._sync_up_mapping_table(self.mapping_table, self.db, number)
#           print '[debug]: the self.db is %s'%self.db
#           print '[debug]: the type of self.db is %s'%type(self.db)
#           print '[debug]: the mapping table is %s'%self.mapping_table
#           print '[debug]: the type of mapping table is %s'%type(self.mapping_table)

    def _sync_up_mapping_table(self, mapping_table, local_db, number):
        dic_map = mapping_table
        dic_local = local_db
        #[for debug purposes]                dic_local['test_name'] = 'test_number'
        temp_dic = {}
        temp_list = []
        for key in dic_map.keys():
            if dic_map[key] == 'server%s'%number:
                temp_dic[key] = 'server%s'%number
                
        if dic_local.viewkeys() == temp_dic.viewkeys():
                print "[info][%s]SELF_TEST: DB on server#%s synced up with mapping table"%((str(datetime.now())), number)
                logging.info("[info][%s]SELF_TEST: DB on server#%s synced up with mapping table" %((str(datetime.now())), number))
        else:
                if list(dic_local.viewkeys() - temp_dic.viewkeys()):
                   for each in list(dic_local.viewkeys() - temp_dic.viewkeys()):
                       self.mapping_table[each] = 'server%s'%number
                       temp_list.append(each)
                   #update the mapping table
                   with open('mapping_table.json', 'w') as f:
                       json.dump(self.mapping_table, f)
                   print '[info][%s]mapping table updated -- new key \'%s\' added to mapping table from server#%s'%((str(datetime.now())), str(temp_list), number)
                   logging.info("[info][%s]mapping table updated -- new key \'%s\' added to mapping table from server#%s"%((str(datetime.now())), str(temp_list), number))
                if list(temp_dic.viewkeys() - dic_local.viewkeys()):
                   print '[WARNING][%s]: mapping table contains key -- \'%s\' that does not exist on local DB server#%s'%((str(datetime.now())), str(list(temp_dic.viewkeys() - dic_local.viewkeys())), number)
                   logging.info('[WARNING][%s]: mapping table contains key -- \'%s\' that does not exist on local DB server#%s'%((str(datetime.now())), str(list(temp_dic\
.viewkeys() - dic_local.viewkeys())), number))
        
        
    def pull_mapping_table(self, number):
        if not os.path.isfile('mapping_table.json'):
            data = {
                'Jaylene%s'%number : 'server_%s'%number,
                'Weihan%s'%number : 'server_%s'%number,
            }
            with open('mapping_table.json', 'w') as f:
                json.dump(data, f)

        if os.path.isfile('mapping_table.json'):
            with open('mapping_table.json', 'r') as f:
                self.mapping_table = json.load(f)


    def distributed_db_init(self, number):
        # initiate a distributed DB once server gets running

        if not os.path.isfile('database_no%s.db'%number):
           self.db = {'Jaylene%s'%number: '2533550659', 'Weihan%s'%number: '2065197252'}           
           pickle.dump(self.db, open('database_no%s.db'%number, 'wb'))
        if (os.path.isfile('database_no%s.db'%number)):
           self.db = pickle.load(open('database_no%s.db'%number, 'rb'))

    def get_request(self, request):
        print "\n[INFO][%s]+++++++++ new requesting coming in +++++++++" %str(datetime.now())
        logging.info('[INFO][%s]:+++++++++ new requesting coming in ++++++++.' %str(datetime.now()))
        print "[INFO][{0}]Following request coming from Client:".format(str(datetime.now()))
        logging.info('[INFO][{0}]Request coming from Client:'.format(str(datetime.now())))
#        self.db_init()   no longer needed as db has been replaced by distributed db def
        self.data = request
        print "[INFO]Request detail --> \"{0}\"".format(self.data)
        parsed_data = self.input_parser()
        sent_back_db_value = self.db_operation(parsed_data)
        print "[INFO][%s]Server responding -->  %s" %(str(datetime.now()),sent_back_db_value)
        logging.info("[INFO][%s]Server responding -->  %s" %(str(datetime.now()),sent_back_db_value))
        print "[INFO][%s]+++++++++ this request session completes ++++++++\n" %str(datetime.now())
        logging.info("[INFO][%s]+++++++++ this request session completes ++++++++"%str(datetime.now()))
        return "{0}".format(sent_back_db_value)

    def replace_acronym(self,a_dict,check_for,replacement_key,replacement_text):
        c = a_dict.get(check_for)
        if c is not None:
          del a_dict[check_for]
          a_dict[replacement_key] = replacement_text
          self.db = a_dict
        elif c is None:
          a_dict[replacement_key] = replacement_text
          self.db = a_dict
          print self.db
        pickle.dump(self.db, open('database_no1.db', 'wb'))#hard-coded for now
        return self.db

    def purge_db(self,a_dict,check_for):
        c = a_dict.get(check_for)
        if c is not None:
          del a_dict[check_for]
          self.db = a_dict
          pickle.dump(self.db, open('database_no1.db', 'wb'))  #hard-coded for now
        elif c is None:
          pass   #here need send warning message to client



    def db_operation(self, input):
        # initiate a DB once server gets running
#        self.db = {'Jaylene': '2533550659', 'Weihan': '2065197252'}
        if re.findall(r"error_input", input[0]):
           return 'Invalid Input, now we support four oprands {QUERY|GET arg1|PUT arg1 arg2|DELETE arg1}'
        if re.findall(r"GET", input[0]):
           if (input[1] in self.db): 
              return_string = "The value of KEY \"%s\" is %s" %(input[1],self.db[input[1]])
              return return_string
           else:
              return_string = "The KEY is not in DB. Try {QUERY} or {PUT} to add one." 
              return return_string
        if re.findall(r"PUT", input[0]):
#           self.db[input[1]] = input[2]
           self.replace_acronym(self.db,input[1],input[1],input[2]) 
           return_string = "Key/Value Pair {%s/%s} has been added to DB" %(input[1],input[2])
           return return_string
        if re.findall(r"QUERY", input[0]):
           return_string = "DB status: %s"% self.db
           return return_string
        if re.findall(r"DELETE", input[0]):
           self.purge_db(self.db,input[1]) 
           return_string = "Key/Value Pair of KEY {%s} has been purged from DB" %(input[1])
           return return_string


    def input_parser(self):
        #parses the query from client, to check either it is a PUT or GET

        m = re.match(r"(?P<KEY>\w+) (?P<INPUT>.*)", "%s" %self.data)
        if (m.group('KEY') == 'QUERY'):
          return ['QUERY'] 
        if (m.group('KEY') == 'PUT'):
          m1 = re.match(r"(?P<INPUT1>\w+) (?P<INPUT2>\w+)", m.group('INPUT'))
          return [m.group('KEY'),m1.group('INPUT1'),m1.group('INPUT2')] 
        elif not (m.group('KEY') == 'PUT'):
          return [m.group('KEY'),m.group('INPUT')]
        else:
          return ['error_input']


if __name__=='__main__':
    server_number = '1'
    logging.basicConfig(filename='server_rpc_no1.log', level=logging.INFO)
    server_initializer=RPC_Server(server_number)
#    logger = logging.getLogger('server_rpc_no1.log')
#    logger.setLevel(logging.DEBUG)
#    logger.basicConfig(filename='server_rpc_no1.log', level=logging.DEBUG, filemode='w')
    logging.basicConfig(filename='server_rpc_no%s.log'%server_number, level=logging.INFO)
    print '[info][%s]:Name space \'server_no%s.tcss558\' assigned to server#%s.' %(str(datetime.now()), server_number, server_number)
    logging.info('[info][%s]:Name space \'server_no%s.tcss558\' assigned to server#%s.' %(str(datetime.now()), server_number, server_number))
    os.system("nohup python -m Pyro4.naming &")
    daemon=Pyro4.Daemon()                 # make a Pyro daemon
    ns=Pyro4.locateNS()                   # find the name server
    uri=daemon.register(server_initializer)   # register the object as a Pyro object
    ns.register("server_no1.tcss558", uri)  # register the object with a name in the name server
    print "[info]Server #1 is Up and Running."
    logging.info('[%s]:Server #1 Started.' %str(datetime.now()))
    daemon.requestLoop()                  # start the event loop of the server to wait for calls


